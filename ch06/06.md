## 6.指针
- 无论程序员还是计算机都无法通过值的位模式来判断它的类型。类型是通过值的使用方法隐式确定的。编译器能够保证值的声明和值的使用之间的关系是适当的。编译器能够保证值的声明和值的使用之间的关系是适当的，从而帮助我们确定值的类型。
- 声明一个指针变量并不会自动分配任何内存。在对指针执行间接访问前，指针必须进行初始化：或者使它指向现有的内存，或者给它分配动态内存。对未初始化的指针变量执行间接访问操作是非法的，而且这种错误常常难以检测。其结果常常是一个不相关的值被修改。这种错误是很难被调试发现的。
- NULL指针就是不指向任何东西的指针。它可以赋值给一个指针，用于表示那个指针并不指向任何值。对NULL指针执行间接访问的后果因编译器而异，两个常见的后果分别是返回内存位置零的值以及终止程序。
- 除了NULL指针之外，再也没有任何内建的记法来表示指针常量，因为程序员无法预测编译器会把变量放在内存中的什么位置。在极少见的情况下，我们偶尔需要使用指针常量，这时我们可以通过把一个整型值强制转换为指针类型来创建它。*(int *)100 = 25,(int *)100表示在指向整型的指针100。
- `指针运算只有作用在数组中结果才是可以预测的，对任何并非指向数组元素的指针执行算术运算是非法的（但是常常难以检测到）。如果一个指针减去一个整数后，运算结果产生的指针所指向的位置在数组的第一个元素之前，那么它也是非法的，加法运算稍有不同，如果结果指针指向数组最后一个元素后面的那个内存位置仍是合法（但不能对这个指针执行间接访问操作），不过再往后就不合法了。`
```
#define N_VALUES 5
float values[N_VALUES];
float *vp;

for(vp=&values[0];vp<&values[N_VALUES];)
    *vp++ = 0;

for(vp=&values[N_VALUES];vp>&values[0];)
    *--vp = 0;

// 下面的不合法,比较vp>=&values[0]的值是未定义的，因为vp移动到了数组的边界之外。但是大多数编译器都能让它工作
for(vp=&values[N_VALUES-1];vp>=&values[0];vp--)
    *vp = 0;
```
- 如果两个指针都指向同一个数组中的元素，那么它们之间可以相减。指针减法的结果经过调整（除以数组元素类型的长度），表示两个指针在数组中相隔多少个元素。如果两个指针并不是指向同一个数组的元素，那么它们之间进行相减就是错误的。
- 任何指针之间都可以进行比较，测试它们相等或不相等。如果两个指针都指向同一个数组中的元素，那么它们之间还可以执行<、<= 、>、>=等关系运算，用于判断数组的相对位置。对于两个不相关的指针执行关系运算，其结果未定义。